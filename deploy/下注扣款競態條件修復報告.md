# 下注扣款系统竞态条件修复报告

## 问题描述

用户反映下注时余额扣除不正确的问题：
- 下注 500 只扣 400
- 下注 700 只扣 400
- 多笔同时下注时扣款金额与预期不符

## 问题分析

经过深入分析系统代码和测试，发现问题根源为**并发扣款的竞态条件（Race Condition）**。

### 1. 现有扣款流程问题

代理系统的 `MemberModel.updateBalance` 使用了非原子性的「读取-计算-更新」模式：

```javascript
// 问题代码
const member = await this.findByUsername(username);
const beforeBalance = parseFloat(member.balance);
const afterBalance = beforeBalance + parseFloat(amount);
// 两个并发请求可能都读到相同的 beforeBalance
await db.one(`UPDATE members SET balance = $1 WHERE username = $2`, [afterBalance, username]);
```

### 2. 并发场景分析

当用户一次下注多笔时（例如3笔×100元）：
1. 前端同时发送3个请求到后端
2. 3个请求几乎同时执行扣款
3. 由于没有锁机制，可能出现：
   - 请求A和B都读到余额1000
   - 请求A计算后更新为900
   - 请求B也计算后更新为900（覆盖了A的结果）
   - 最终只扣了100元而非200元

### 3. 测试验证

通过 `test-balance-deduction.cjs` 测试脚本重现了问题：
- 初始余额：369元
- 并发下注：3笔×100元 = 300元
- 预期余额：69元
- 实际余额：169元（只扣了200元）

## 解决方案

### 1. 资料库层面：创建原子性函数

创建了三个关键的 PostgreSQL 函数：

#### a) 安全的单笔扣款函数
```sql
CREATE OR REPLACE FUNCTION safe_bet_deduction(
    p_username VARCHAR,
    p_amount DECIMAL,
    p_bet_id VARCHAR
) RETURNS TABLE(success BOOLEAN, message VARCHAR, balance DECIMAL)
```
- 使用 `FOR UPDATE` 行级锁防止并发修改
- 原子性执行扣款操作

#### b) 批量扣款函数
```sql
CREATE OR REPLACE FUNCTION batch_bet_deduction(
    p_username VARCHAR,
    p_bets JSONB
) RETURNS TABLE(...)
```
- 支援一次扣除多笔下注
- 计算总金额后一次性扣除
- 避免多次并发操作

#### c) 原子性余额更新函数
```sql
CREATE OR REPLACE FUNCTION atomic_update_member_balance(
    p_username VARCHAR,
    p_amount DECIMAL
) RETURNS TABLE(...)
```
- 替代原有的非原子性实现
- 使用单一事务完成读取和更新

### 2. 应用层面：修改扣款逻辑

#### a) 修改 MemberModel.updateBalance
```javascript
// 新的实现
const result = await db.one(`
  SELECT * FROM atomic_update_member_balance($1, $2)
`, [username, amount]);
```

#### b) 新增批量扣款 API
```javascript
app.post(`${API_PREFIX}/batch-deduct-member-balance`, async (req, res) => {
  // 支援批量下注扣款
  // 使用 batch_bet_deduction 函数
  // 包含降级处理机制
});
```

### 3. 防护机制

1. **下注锁定表**：防止重复下注
2. **事务处理**：确保扣款和记录的一致性
3. **降级处理**：当新函数不存在时，使用事务+行锁处理

## 实施步骤

1. **执行 SQL 脚本**
   ```bash
   psql -U username -d database -f fix-bet-deduction-system.sql
   ```

2. **更新代理后端**
   - 已修改 `agentBackend.js` 的 `MemberModel.updateBalance`
   - 已添加批量扣款 API

3. **测试验证**
   ```bash
   node test-batch-betting.cjs
   ```

## 预期效果

1. **单笔下注**：使用原子性函数，避免竞态条件
2. **多笔下注**：
   - 优先使用批量扣款 API
   - 一次性计算总额并扣除
   - 避免多次并发操作
3. **性能提升**：批量处理减少资料库交互次数

## 后续建议

1. **前端优化**：修改为使用批量下注 API
2. **监控机制**：添加扣款异常监控
3. **定期对帐**：确保余额一致性
4. **压力测试**：定期进行并发测试

## 技术细节

### PostgreSQL 行级锁
- `SELECT ... FOR UPDATE`：获取行级排他锁
- 其他事务必须等待锁释放
- 确保同一时间只有一个事务能修改余额

### 事务隔离级别
- 使用默认的 READ COMMITTED
- 配合行级锁实现并发安全

### 性能考量
- 行级锁只锁定特定会员记录
- 不影响其他会员的操作
- 批量处理减少锁竞争

## 总结

通过实施原子性扣款函数和批量处理机制，彻底解决了并发下注时的余额扣除不一致问题。系统现在能够：
- 正确处理并发扣款请求
- 确保余额扣除的准确性
- 提供更好的性能和可靠性 